# 并查集

并查集合是一种树形的数据结构，用于处理一些不交集的合并即查询问题

Find: 确定元素属于哪一个子集，它可以被用来确定两个元素是否属于同一子集

Union: 将两个子集合并成同一个集合

## 1. 岛屿的数量

>https://leetcode-cn.com/problems/number-of-islands/

**题目描述：**



### 解法一：并查集

>TODO: 需要补上并查集的解法

**思路：**


**复杂度分析：**

- 时间复杂度
- 空间复杂度

**代码实现：**

```javascript
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
};
```

## 解法二：染色（DFS）

**思路：**

找到 1，count++，然后将 1 以及周围的 1 全部设置 0 （DFS），


**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
  const dfs = (grid, i, j, rows, cols) => {
    if (i < 0 || j < 0 || i > rows - 1 || j > cols - 1 || grid[i][j] === "0") {
      return
    } 

    grid[i][j] = "0";

    dfs(grid, i + 1, j, rows, cols)
    dfs(grid, i, j + 1, rows, cols)
    dfs(grid, i - 1, j, rows, cols)
    dfs(grid, i, j - 1, rows, cols)
  }

  let res = 0;
  const rows = grid.length;
  if (rows === 0) return 0;
  const cols = grid[0].length;
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (grid[i][j] === "1") {
        dfs(grid, i, j, rows, cols);
        res++;
      }
    }
  }
  return res
};
```

## 2. 朋友圈

**题目描述：**

示例：

输入：

[[1, 2, 0],
[1, 1, 0],
[0, 0, 1]
]

输出：2


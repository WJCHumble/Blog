# 队列

特点：

- 先进先出

>它的实现可以是数组或双链表

## 优先队列

特点：

- 正常进，按照优先级出

>实现机制，堆、二叉搜索树，二叉堆的性能是最好的，严格二叉堆的性能也是最好的

### 小顶堆 Mini Heap

特点：父亲节点比左右孩子都小，最小的元素永远在堆顶

### 大顶堆 Max Heap

特点：父亲节点比左右孩子都大，最大的元素永远在堆顶

## 1. 用队列实现栈

>https://leetcode-cn.com/problems/implement-stack-using-queues/

问题描述：

### 解法一：

**思路：**

**复杂度分析：**

时间复杂度：
空间复杂度：

**代码实现：**

```javascript
/**
 * Initialize your data structure here.
 */
var MyStack = function() {
    this.queue = [];
};

/**
 * Push element x onto stack. 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue.push(x)
};

/**
 * Removes the element on top of the stack and returns that element.
 * @return {number}
 */
MyStack.prototype.pop = function() {
    const temp = []
    for(let i = 0; i < this.queue.length - 1; i++) {
        temp.push(this.queue[i])
    }
    const res = this.queue[this.queue.length - 1];
    this.queue = temp;
    return res;
};

/**
 * Get the top element.
 * @return {number}
 */
MyStack.prototype.top = function() {
    if (!this.queue.length) return null
    return this.queue[this.queue.length - 1]
};

/**
 * Returns whether the stack is empty.
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue.length === 0
};

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
```

## 2. 返回数据流中的第 K 大元素

>https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/

**题目描述：**

设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。

### 解法一

**思路：**

对初始数据进行排序（倒叙），每次进来一个元素都遍历该数据，将该元素插入刚好小于等于它的位置。

**复杂度分析：**

时间复杂度：O(nlogn)
空间复杂度：O(n)

**代码实现：**

```javascript
var KthLargest = function(k, nums) {
  this.minHeap = nums.sort((a, b) => b - a)
  this.k = k
}

KthLargest.prototype.add = function(val) {
  let pos = this.minHeap.length
  for(let i = 0; i < pos; i++) {
    if (val >= this.minHeap[i]) {
      pos = i
      break
    }
  }
  this.minHeap.splice(pos, 0, val)
  return this.minHeap[this.k - 1]
}
```

## 3. 滑动窗口最大值

>https://leetcode-cn.com/problems/sliding-window-maximum/

**题目描述：**

给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

示例：

输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3

输出: [3,3,5,5,6,7] 

### 解法一：双端队列（推荐）

>双端队列指的是可以在队列两端进行插入和删除操作

**思路：**

这里我们分两个步骤讲解：移动、维护：

- 每次移动滑动窗口的时候，我们需要去掉超出窗口左边边界索引的队头元素，即队头出队的过程。
- 每次枚举 nums，需要判断 nums[i] 是否小于队尾的元素，是则进队，否则枚举 windows，直至 `nums[windows[windows.length - 1]] > nums[i]` 或者 `windows.length` 不存在。

**复杂度分析：**

时间复杂度：O(n)
空间复杂度：O(1)

**代码实现：**

```javascript
var maxSlidingWindow = function(nums, k) {
    if (!nums.length) return [];

    const ans = [],
        windows = [];

    for (let i = 0; i < nums.length; i++) {
        if (i >= k && windows[0] <= i - k) windows.shift();

        while(windows.length && nums[windows[windows.length-1]] <= nums[i]) {
            windows.pop();
        }
        windows.push(i);
        
        if (i >= k - 1) ans.push(nums[windows[0]]);
    }
    return ans;
}
```

### 解法二：双指针

**思路：**

**复杂度分析：**

时间复杂度：
空间复杂度：

**代码实现：**

```javascript

```

### 解法三：大顶堆

**思路：**

**复杂度分析：**

时间复杂度：
空间复杂度：

**代码实现：**

```javascript

```

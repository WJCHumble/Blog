# 树

>链表是特殊的树，树是特殊的图

**广度优先搜索 BFS：**

理论：逐层访问树的节点，并不断访问改层的子节点。

>它是队列的数据结构

**深度优先搜索 DFS：**

理论：对每个树都访问到叶子节点，然后再回去访问其他树

>这个过程借助的是递归，所以是栈的数据结构

## 二叉树

1. 前序(Pre-order)：根-左-右
2. 中序(In-order)：左-根-右
3. 后序(Post-order)：左-右-根

## 二叉搜索树

二叉搜索树（Binary Search Tree），也称二叉搜索树、有序二叉树，排序二叉树，是指一颗空树或者具备下列性质的二叉书。

特点：

- 左子树上所有节点的值均小于它的根节点的值
- 右子树上所有节点的值均大于它的根节点的值
- Recursively，左、右子树也分别为二叉查找树

时间复杂度：

- 访问、搜索、插入、删除节点都是 O(log(n))（最糟糕情况为 O(n)，这个时候就只有左子树或右子树，相当于链表）
- O(log(n))

## 1. 验证二叉搜索树

>https://leetcode-cn.com/problems/validate-binary-search-tree/

**题目描述：**

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

示例：

输入:
    2
   / \
  1   3
  
输出: true

### 解法一：中序遍历

**思路：**

由于二叉搜索中序遍历的结果是升序的

**复杂度分析：**

时间复杂度：O(n)
空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  let stack = [];
  let inorder = -Infinity;

  while(stack.length || root !== null) {
    while(root !== null) {
      stack.push(root);
      root = root.left;
    }
    root = stack.pop();
    // 如果中序遍历得到的节点值小于等于前一个 inorder，说明不是二叉搜索树
    if (root.val <= order) {
      return false;
    }
    in = root.val;
    root = root.right
  }

  return true;
}
```

### 解法二：递归 + 最大值和最小值验证

**思路：**

递归左右子树（注意是所有左右子树），左子树上的节点需要都小于根节点的值，右子树上的节点需要都大于根节点上的值。

**复杂度分析：**

时间复杂度：O(n)
空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root, min, max) {
    if (root === null) return true;
    if (min !== null && root.val <= min) return false;
    if (max !== null && root.val >= max) return false;

    return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);
};
```

## 2. 二叉树的最近公共祖先

>https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/

>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

**题目描述：**

### 解法一：递归

**抽象模型：**

>首先判断 root 是否为空、是否等于 p 或 q，是则直接返回 root，否则分别递归左右子树，如果左子树为 null，则返回右子树，如果右子树为 null，则返回左子树，如果左右子树都为 null，则返回 root。


**复杂度分析：**

时间复杂度：
空间复杂度：

**代码分析：**

```javascript
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (root === null || root === p || root === q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    
    return left === null ? right : right === null ? left : root;
};
```

## 3. 二叉搜索树的最近公共祖先

>https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

**题目描述：**

### 解法一：递归

**思路：**

利用二叉搜索树的特点，当 p q 都小于 root 的时候去左子树查找，当 p q 都大于 root 的时候去右子树查找，否则就是 root，因为 p q 分别分布在左右子树了，此时显然 root 最近。

**复杂度分析：**

时间复杂度：O(n)
空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (p.val < root.val && q.val < root.val) {
      return lowestCommonAncestor(root.left, p, q);
    }

    if (p.val > root.val && root.val < q.val) {
      return lowestCommonAncestor(root.right, p, q);
    }

    return root;
};
```

### 解法二：迭代

**思路：**

**复杂度分析：**

时间复杂度：
空间复杂度：

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    while(root) {
      if (p.val < root.val && q.val < root.val) {
        root = root.left
      } else if (p.val > root.val && q.val > root.val) {
        root = root.right;
      } else {
        return root;
      }
    }
};
```

## 3. 二叉树的层序遍历

>https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

**题目描述：**

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：

    3
   / \
  9  20
    /  \
   15   7

[
  [3],
  [9,20],
  [15,7]
]

### 解法一：BFS

**思路：**


**复杂度分析：**

时间复杂度：O(n)

空间复杂度：

**代码分析：**

```javascript
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if (!root) return []

    const result = []
    const queue = [root]

    while(queue.length !== 0) {
        const currentLeveSize = queue.length;
        // 初始化当前层
        result.push([])

        for (let i = 0; i < currentLeveSize; i++) {
            // 获取节点
            let node = queue.shift();
            // 将节点的值放入当前层
            result[result.length - 1].push(node.val);

            // 判断改节点是否存在子节点，存在则加入下一层
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
    }

    return result
};
```

### 解放二：DFS

**思路：**

**复杂度分析：**

时间复杂度：O(n)

空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var dfsFn = function (result, node, level) {
  if (!node) return
  if (result.length < level + 1) result.push([])

  result[level].push(node.val)
  dfsFn(result, node.left, level + 1)
  dfsFn(result, node.right, level + 1)
}

var levelOrder = function(root) {
  if (!root) return []
  const result = []
  dfsFn(result, root, 0)

  return result
};
```

## 4. 二叉树的最大深度

>https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/

**题目描述：**

给定一个二叉树，找出其最大深度。

示例：

    3
   / \
  9  20
    /  \
   15   7

返回它的最大深度 3 。

### 解法一：递归 + 分治

**思路：**

**复杂度分析：**

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

### 解法二：BFS

**思路：**

**复杂度分析：**

**代码实现：**

```javascript

```

### 解法三：DFS

**思路：**

**复杂度分析：**

**代码实现：**

```javascript

```

## 5. 二叉树的最小深度

>https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/

给定一个二叉树，找出其最小深度。

示例：

    3
   / \
  9  20
    /  \
   15   7

返回它的最小深度 2

### 解法一：递归 + 分治

**思路：**

**复杂度分析：**

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(!root) return 0;

    const left = minDepth(root.left);
    const right = minDepth(root.right);

    return (left === 0 || right === 0) ? left + right + 1 : Math.min(left, right) + 1
};
```



## 7. 先序遍历

**题目描述：**

给定一个二叉树，返回它的前序（先序）遍历序列

示例：

输入 [1, null, 2, 3]

输出 [1, 2, 3]

>这种输入树的数组表示着 root left right 的结构

### 解法一：迭代

**思路：**

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
const preorderTraversal = function(root) {
  const result = []

  if (!root) {
    return res
  }

  const stack = []
  stack.push(root)
  while(stack.length) {
    const cur = stack.pop()
    result.push(cur.valu)

    if (cur.right) {
      stack.push(cur.right)
    }

    if (cur.left) {
      stack.push(cur.left)
    }
  }

  return result
}
```

### 解法二：递归

## 8. 后序遍历

**题目描述：**

### 解法一：迭代

**思路：**



**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
const postorderTraversal = function(root) {
  const result = []
  if (!root) return result

  const stack = []
  stack.push(root)
  while(stack.length) {
    const cur = stack.pop()
    res.unshift(cur.val)
    if (cul.left) {
      stack.push(cur.left)
    }
    if (cur.right) {
      stack.push(cur.right)
    }
  }

  return res
}
```

## 9. 中序遍历

**题目描述：**

### 解法一：迭代

**思路：**


**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
const inorderTraversal = function(root) {
  const result = []
  const stack = []
  let cur = root

  while(cur || stack.length) {
    while(cur) {
      stack.push(cur)
      cur = cur.left
    }

    cur = stack.pop()
    res.push(cur.val)
    cur = cur.right
  }

  return result
}
```


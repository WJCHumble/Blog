# 树

>链表是特殊的树，树是特殊的图

**广度优先搜索 BFS：**

理论：逐层访问树的节点，并不断访问改层的子节点。

>它是队列的数据结构

**深度优先搜索 DFS：**

理论：对每个树都访问到叶子节点，然后再回去访问其他树

>这个过程借助的是递归，所以是栈的数据结构

## 二叉树

1. 前序(Pre-order)：根-左-右
2. 中序(In-order)：左-根-右
3. 后序(Post-order)：左-右-根

## 二叉搜索树

二叉搜索树（Binary Search Tree），也称二叉搜索树、有序二叉树，排序二叉树，是指一颗空树或者具备下列性质的二叉书。

特点：

- 左子树上所有节点的值均小于它的根节点的值
- 右子树上所有节点的值均大于它的根节点的值
- Recursively，左、右子树也分别为二叉查找树

时间复杂度：

- 访问、搜索、插入、删除节点都是 O(log(n))（最糟糕情况为 O(n)，这个时候就只有左子树或右子树，相当于链表）
- O(log(n))

## 1. 验证二叉搜索树

>https://leetcode-cn.com/problems/validate-binary-search-tree/

**题目描述：**

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

示例：

输入:
    2
   / \
  1   3
  
输出: true

### 解法一：中序遍历

**思路：**

由于二叉搜索中序遍历的结果是升序的

**复杂度分析：**

时间复杂度：O(n)
空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
  let stack = [];
  let inorder = -Infinity;

  while(stack.length || root !== null) {
    while(root !== null) {
      stack.push(root);
      root = root.left;
    }
    root = stack.pop();
    // 如果中序遍历得到的节点值小于等于前一个 inorder，说明不是二叉搜索树
    if (root.val <= order) {
      return false;
    }
    in = root.val;
    root = root.right
  }

  return true;
}
```

### 解法二：递归 + 最大值和最小值验证

**思路：**

递归左右子树（注意是所有左右子树），左子树上的节点需要都小于根节点的值，右子树上的节点需要都大于根节点上的值。

**复杂度分析：**

时间复杂度：O(n)
空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root, min, max) {
    if (root === null) return true;
    if (min !== null && root.val <= min) return false;
    if (max !== null && root.val >= max) return false;

    return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);
};
```

## 2. 二叉树的最近公共祖先

>https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/

>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

**题目描述：**

### 解法一：递归

**抽象模型：**

>首先判断 root 是否为空、是否等于 p 或 q，是则直接返回 root，否则分别递归左右子树，如果左子树为 null，则返回右子树，如果右子树为 null，则返回左子树，如果左右子树都为 null，则返回 root。


**复杂度分析：**

时间复杂度：
空间复杂度：

**代码分析：**

```javascript
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (root === null || root === p || root === q) return root;
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    
    return left === null ? right : right === null ? left : root;
};
```

## 3. 二叉搜索树的最近公共祖先

>https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

**题目描述：**

### 解法一：递归

**思路：**

利用二叉搜索树的特点，当 p q 都小于 root 的时候去左子树查找，当 p q 都大于 root 的时候去右子树查找，否则就是 root，因为 p q 分别分布在左右子树了，此时显然 root 最近。

**复杂度分析：**

时间复杂度：O(n)
空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (p.val < root.val && q.val < root.val) {
      return lowestCommonAncestor(root.left, p, q);
    }

    if (p.val > root.val && root.val < q.val) {
      return lowestCommonAncestor(root.right, p, q);
    }

    return root;
};
```

### 解法二：迭代

**思路：**

**复杂度分析：**

时间复杂度：
空间复杂度：

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    while(root) {
      if (p.val < root.val && q.val < root.val) {
        root = root.left
      } else if (p.val > root.val && q.val > root.val) {
        root = root.right;
      } else {
        return root;
      }
    }
};
```

## 3. 二叉树的层序遍历

>https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

**题目描述：**

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：

    3
   / \
  9  20
    /  \
   15   7

[
  [3],
  [9,20],
  [15,7]
]

### 解法一：BFS

**思路：**


**复杂度分析：**

时间复杂度：O(n)

空间复杂度：

**代码分析：**

```javascript
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if (!root) return []

    const result = []
    const queue = [root]

    while(queue.length !== 0) {
        const currentLeveSize = queue.length;
        // 初始化当前层
        result.push([])

        for (let i = 0; i < currentLeveSize; i++) {
            // 获取节点
            let node = queue.shift();
            // 将节点的值放入当前层
            result[result.length - 1].push(node.val);

            // 判断改节点是否存在子节点，存在则加入下一层
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
    }

    return result
};
```

### 解法二：DFS

**思路：**

**复杂度分析：**

时间复杂度：O(n)

空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var dfsFn = function (result, node, level) {
  if (!node) return
  if (result.length < level + 1) result.push([])

  result[level].push(node.val)
  dfsFn(result, node.left, level + 1)
  dfsFn(result, node.right, level + 1)
}

var levelOrder = function(root) {
  if (!root) return []
  const result = []
  dfsFn(result, root, 0)

  return result
};
```

## 4. 二叉树的最大深度

>https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/

**题目描述：**

给定一个二叉树，找出其最大深度。

示例：

    3
   / \
  9  20
    /  \
   15   7

返回它的最大深度 3 。

### 解法一：递归 + 分治

**思路：**

**复杂度分析：**

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
};
```

### 解法二：BFS

**思路：**

**复杂度分析：**

**代码实现：**

```javascript

```

### 解法三：DFS

**思路：**

**复杂度分析：**

**代码实现：**

```javascript

```

## 5. 二叉树的最小深度

>https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/

给定一个二叉树，找出其最小深度。

示例：

    3
   / \
  9  20
    /  \
   15   7

返回它的最小深度 2

### 解法一：递归 + 分治

**思路：**

**复杂度分析：**

**代码实现：**

```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(!root) return 0;

    const left = minDepth(root.left);
    const right = minDepth(root.right);

    return (left === 0 || right === 0) ? left + right + 1 : Math.min(left, right) + 1
};
```

## 6. 先序遍历

**题目描述：**

给定一个二叉树，返回它的前序（先序）遍历序列

示例：

输入 [1, null, 2, 3]

输出 [1, 2, 3]

>这种输入树的数组表示着 root left right 的结构

### 解法一：迭代

**思路：**

用栈解决，每次枚举将栈顶节点出栈，然后先将右孩子进栈，左孩子进栈，继续枚举

>之所以右孩子先进、左孩子后进，是因为先序遍历要根 -> 左孩子 -> 右孩子

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
const preorderTraversal = function(root) {
  const result = []

  if (!root) {
    return res
  }

  const stack = []
  stack.push(root)
  while(stack.length) {
    // 当前节点出栈
    const cur = stack.pop()
    result.push(cur.val)

    // 右节点进栈
    if (cur.right) {
      stack.push(cur.right)
    }


    if (cur.left) {
      stack.push(cur.left)
    }
  }

  return result
}
```

### 解法二：递归

## 7. 后序遍历

>left right root

**题目描述：**

### 解法一：迭代

**思路：**


**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
const postorderTraversal = function(root) {
  const result = []
  if (!root) return result

  const stack = []
  stack.push(root)
  while(stack.length) {
    const cur = stack.pop()
    res.unshift(cur.val)
    if (cul.left) {
      stack.push(cur.left)
    }
    if (cur.right) {
      stack.push(cur.right)
    }
  }

  return res
}
```

## 8. 中序遍历

**题目描述：**

### 解法一：迭代

**思路：**


**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
const inorderTraversal = function(root) {
  const result = []
  const stack = []
  let cur = root

  while(cur || stack.length) {
    while(cur) {
      stack.push(cur)
      cur = cur.left
    }

    cur = stack.pop()
    res.push(cur.val)
    cur = cur.right
  }

  return result
}
```

## 层从上到下打印二叉树 II

>https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/

题目描述：

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）

示例：

二叉树：[3,9,20,null,null,15,7],

输出：

  3
 / \
9  20
  /  \
 15   7


BFS + 队列

```javascript
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
const levelOrder = function(root) {
  // 初始化结果数组
  const res = []
  // 处理边界条件
  if (!root) {
    return res
  }
  // 初始化队列
  const queue = []
  // 队列第一个元素是根节点
  queue.push(root)
  while(queue.length) {
    const level = []
    const len = queue.length

    for (let i = 0; i < len; i++) {
      const top = queue.shift()
      level.push(top.val)
      if (top.left) {
        queue.push(top.left)
      }

      if (top.right) {
        queue.push(top.right)
      }
    }

    res.push(level)
  }

  return res
}
```

## 9. 单词搜索

>https://leetcode-cn.com/problems/word-search-ii/

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。

**题目描述：**

示例：

输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]

输出：["eat","oath"]


### 解法一：字典树

**思路：**



**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(board, words) {
  const h = {}, r = [];

  // 遍历单词表
  for (const w of words) {
    for (let i = 0, t = h, p; i < w.length; i++) {
      if (!t[w[i]]) {
        t[w[i]] = Object.create(null);
        t[w[i]]
      }
    }
  }
};
```

## 10. 重建二叉树

>https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
  const dic = new Map()
  const recur = (root, left, right) => {
    if (left > right) return null

    const node = new TreeNode(preorder[root])
    let i = dic.get(preorder[root])
    node.left = recur(root + 1, left, i - 1)
    node.right = recur(root + i - left + 1, i + 1, right)

    return node
  }

  for (let i = 0; i < inorder.length; i++) {
    dic.set(inorder[i], i)
  }
  return recur(0, 0, inorder.length - 1)
};
```

## 11. 树的子结构

>https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/

题解：

>https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/

思路：

- 递归 isSubStructure，找到 A B 相同的第一个点
- 递归 recur，判断是否 A B 的子树也相同

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} A
 * @param {TreeNode} B
 * @return {boolean}
 */
var isSubStructure = function(A, B) {
  const recur = (a, b) => {
    if (b === null) return true
    if (a === null || a.val !== b.val) return false

    return recur(a.left, b.left) && recur(a.right, b.right)
  } 

  return (A !== null && B !== null) && (recur(A, B) || isSubStructure(A.right, B) || isSubStructure(A.left, B))
};
```

## 12. 二叉树的镜像

>https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var mirrorTree = function(root) {
  if (root === null) return root

  const tmp = root.left
  root.left = mirrorTree(root.right)
  root.right = mirrorTree(tmp)

  return root
}
```

## 13. 对称的二叉树

>https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/

- 递归左右子树
- 当左右子树都结束的时候则返回 true
- 如果左子树的 val 不等于右子树的 val 或左子树为 null 或右子树为 null 则返回 false

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
  if (root === null) return true
  
  const recur = (L, R) => {
    if (L === null && R === null) return true
    if (L === null || R === null || L.val !== R.val) return false

    recur(L.left, R.right) && recur(L.right, R.left)
  }

  return recur(root.left, root.right)
}
```

## 14. 从上到下打印二叉树木

>https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/

BFS + 队列

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var levelOrder = function(root) {
  if (!root) {
    return []
  }

  const res = [], queue = [root]

  while(queue.length) {
    const cur = queue.shift()
    res.push(cur.val)
    if (cur.left) queue.push(cur.left)
    if (cur.right) queue.push(cur.right)
  }

  return res
}
```

## 14. 从上到下打印二叉树 III

>https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {

};
```

## 15. 二叉树的深度

>https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/

BFS（层序遍历）

```javascript
var maxDepth = function(root) {
    let dep = 0
    if (!root) return dep

    const queue = [root]
    while(queue.length) {
        const len = queue.length

        for (let i = 0; i < len; i++) {
            const cur = queue.shift()
            if (cur.left) {
                queue.push(cur.left)
            }
            if (cur.right) {
                queue.push(cur.right)
            }
        }
        dep++
    }

    return dep
};
```

DFS（后续遍历）

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if （root === null) return 0

  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
}
```

## 16. 二叉搜索树的最近公共祖先

>https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/

递归

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (root.val < p.val && root.val < q.val) {
      return lowestCommonAncestor(root.right, p, q)
    }
    if (root.val > p.val && root.val > q.val) {
      return lowestCommonAncestor(root.left, p, q)
    }

    return root
};
```

## 平衡二叉树

>https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/


### 解法一：后序遍历+剪枝（推荐）

后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则剪枝，直接向上返回

时间复杂度：O(n)

空间复杂度：O(n)

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
 var isBalanced = function(root) {
   const recur = (r) => {
     if (r === null) return 0

     let left = recur(r.left)
     if (left === -1) return -1

     let right = recur(r.right)
     if (right === -1) return -1

     return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1
   }

   return recur(root) !== -1
 }
```

### 解法二：先序遍历+判断深度

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var isBalanced = function(root) {
    if (root === null) return true

    const depth = (r) => {
      if (r === null) return 0

      return Math.max(depth(root.left), depth(root.right)) + 1
    }

    return Math.abs(depth(root.left) - depth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right)
};
```

## 从上到下打印二叉树 III

>https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/

### 解法一：层序遍历 + 双端队列

**思路：**

和传统的层序遍历不同的是，这里需要根据当前的层数改变，每次节点进队的方式，偶数是队尾进队，奇数层是队头进队。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  const queue = [], res = []
  if (root !== null) queue.push(root)

  while (queue.length) {
    const temp = []
    for (let i = queue.length; i > 0; i--) {
      const node = queue.shift()
      // 偶数层，队列头部
      if (res.length % 2 === 0) {
        temp.push(node.val)
      } else { // 奇数层队列尾部
        temp.unshift(node.val)
      }

      if (node.left !== null) {
        queue.push(node.left)
      }
      
      if (node.right !== null) {
        queue.push(node.right)
      }
    }
    res.push(temp)
  }

  return res
};
```

### 层序遍历 + 倒序

>https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  const queue = [], res = []
  if (root !== null) queue.push(root)

  while (queue.length) {
    const temp = []
    for (let i = queue.length; i > 0; i--) {
      const node = queue.shift()
      temp.push(node.val)
      if (node.left !== null) queue.push(node.left)
      if (node.right !== null) queue.push(node.right)
    }

    if (res.length % 2 === 1) temp.reverse()
    res.push(temp)
  }

  return res
}
```

## 二叉树中和为某一值的路径

>https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/

### 回溯

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number[][]}
 */
var pathSum = function(root, sum) {
    const res = [], path = []

    const recur = (r, tar) => {
      if (r === null) return

      path.push(r.val)
      tar -= root.val

      if (tar === 0 && root.left === null && root.right === null) {
        res.push([path])
      }
      recur(root.left, tar)
      recur(root.right, tar)
      path.pop()
    }

    recur(root, sum)
    return res
};
```

## 二叉搜索树的第k大节点

>https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/

### 中序遍历 + 提前返回

第 k 大的节点相当于

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargest = function(root, k) {
  let res = ""
  const dfs = (r) => {
    if (r === null) return

    dfs(r.right)
    if (k === 0) return
    if (--k === 0) res = r.val
    dfs(r.left)
  }

  dfs(root)

  return res
};
```
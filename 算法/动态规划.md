# 动态规划

>动态规划是自底向上的过程，要求我们站在已知的角度，通过定位已知和未知之间的关系，一步步向前推导，进而求解出未知的值。

特点：

- 最优子结构，即问题的最优解包含着子问题的最优解，此后的状态都必须基于当前状态
- 重叠子问题，指的是递归的过程中出现了反复计算的情况

分析步骤：

- 递归思想明确树形思维模型：找到问题终点，思考倒退的过程
- 结合记忆搜索，明确状态转移方程
- 将递归代码转为迭代表达

递归思想：倒着分析问题

1. 定位到问题的终点

2. 站在终点的视角，思考后退的可能性

## 1 爬楼梯问题

>https://leetcode-cn.com/problems/climbing-stairs/

**题目描述：**

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例：

输入： 2

输出： 2

解释： 有两种方法可以爬到楼顶。

1.  1 阶 + 1 阶

2.  2 阶

### 解法一：递归 + 记忆搜索法

**思路：**

我们将走到第 n 阶楼梯的目标对应的路径数记为 f(n)。那么，只能后退一步或两步，对于第 n 阶楼梯只能回退到第 n-1 或者 n-2 阶，可以把 n-1 阶记

f(n) = f(n - 1) + f(n - 2)

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {number} n
 * @return {number}
 */
const fn = []
var climbStairs = function(n) {
  if (n === 1) {
    return 1
  }

  if (n === 2) {
    return 2
  }

  if (fn[n] === undefined) fn[n] = climbStairs(n - 1) + climbStairs(n - 2)

  return fn[n]
};
```

### 解法二：动态规划

**思路：**

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
  const f = [],
  f[1] = 1,
  f[2] = 2;

  for (let i = 3; i <= n; i++) {
    f[i] = f[i - 2] + f[i - 1]
  }

  return f[n]
};
```

## 2 找硬币

### 解法一：动态规划

**思路：**



**复杂度分析：**


**代码实现：**

```javascript
const coinChange = function(coins, amount) {
  const f = []
  f[0] = 0

  for (let i = 1; i <= amount; i++) {
    f[i] = Infinity

    for (let j = 0; j < coins.length; j++) {
      if (i - coins[j] >= 0) {
        f[i] = Math.min(f[i], f[i - coins[j]] + 1)
      }
    }
  }

  if (f[amount] === Infinity) {
    return -1
  }

  return f[amount]
}
```

## 3 背包问题

>TODO: 需要再思考一下

**题目描述：

有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。现在有一个容量为 c 的背包，问你如何选取物品放入背包，才能使得背包内的物品总价值最大？

> 每种物品只有 1 件

### 解法一：动态规划 + 滚动数组

**思路：**

1.明确状态转移方程

假设此时背包已满，即达到容量 c，现在从背包中取出一件物品，这可能会有 i 中可能，则可以用 f(i, c) 来表示前 i 件物品恰好装入容量 c 的背包中所能获取的最大价值。那么，如果此时取出物品 i，i 可能在背包中，也可能不在 i 中，那么z取出 i 背包中的价值不会发生变化，则有：

f(i, c) = f(i - 1, c)

如果取出的物品 i 是在背包中的，则背包的重量会和价值会减少：

f(i, c) - value[i] = f(i - 1, c - w[i])

即

f(i, c) = f(i - 1, c - w[i]) + value[i]

针对取出一个物品 i，在背包中和不在背包中的情况，我们只需要选择两种情况最大价值的一种即可，则有

dp[i][v] = Math.max(dp[i - 1][v], dp[i - 1][v - w[i]] + c[i])

```javascript
for (let i = 1; i <= n; i++) {
  for (let v = w[i]; v <= c; v++) {
    dp[i][v] = Math.max(dp[i - 1][v], dp[i - 1][v -w[i]] + value[i])
  }
}
```

用滚动数组来取代二维数组：

```javascript
for (let i = 1; i <= n; i++) {
  for (let v = c; v >= w[i]; v--) {
    dp[v] = Math.max(dp[v], d[v - w[i]] + value[i])
  }
}
```

2.已知状态（递归边界）

**复杂度分析：**

时间复杂度：O(n)

空间复杂度：O(n^2)

>这里的时间复杂度需要再明确一下

**代码实现：**

```javascript
function knapsack(n, c, w, value) {
  const dp = (new Array(c + 1).fill(0))
  let res = -Infinity
  for (let i = 1; i < n; i++) {
    for (let v = c; v >= w[i]; v--) {
      // 状态转移方程
      dp[v] = Math.max(dp[v], dp[v - w[i]] + value[i])
      // 及时更新最大指
      if(dp[v] > res) {
        res = dp[v]
      }
    }
  }
  return res
}
```

## 4 最长递增子序列

>https://leetcode-cn.com/problems/longest-increasing-subsequence/

**题目描述：**

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

示例：

输入：nums = [10,9,2,5,3,7,101,18]

输出：4

### 解法一：动态规划

**思路：**



**复杂度分析：**

时间复杂度：O(n^2)

空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
  // 缓存序列的长度
  const len = nums.length
  // 处理边界条件
  if (!len) {
    return 0
  }
  // 初始数组里面每个索引位的状态值
  const dp = (new Array(len)).fill(1)
  // 初始化最大上升子序列的长度为 1
  let maxLen = 1
  // 从第 2 个元素开始，遍历整个数组
  for (let i = 1; i < len; i++) {
    // 遍历一个新元素，都要回头看，看看能不能延长原有的上升子序列
    for (let j = 0; j < i; j++) {
      // 如果遇到一个比当前元素小的值，则意味这遇到了一个可以延长的上升子序列，所以更新当前元素索引位对应的状态
      if (nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1)
      }
    }
    // 及时更新上升子序列长度的最大值
    if (dp[i] > maxLen) {
      maxLen = dp[i]
    }
  }

  return maxLen
};
```







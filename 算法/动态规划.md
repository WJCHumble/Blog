# 动态规划

特点：

- 最优子结构，即问题的最优解包含着子问题的最优解，此后的状态都必须基于当前状态
- 重叠子问题，指的是递归的过程中出现了反复计算的情况

分析步骤：

- 递归思想明确树形思维模型：找到问题终点，思考倒退的过程
- 结合记忆搜索，明确状态转移方程
- 将递归代码转为迭代表达

递归思想：倒着分析问题

1. 定位到问题的终点

2. 站在终点的视角，思考后退的可能性

## 1 爬楼梯问题

>https://leetcode-cn.com/problems/climbing-stairs/

**题目描述：**

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例：

输入： 2

输出： 2

解释： 有两种方法可以爬到楼顶。

1.  1 阶 + 1 阶

2.  2 阶

### 解法一：递归 + 记忆搜索法

**思路：**

我们将走到第 n 阶楼梯的目标对应的路径数记为 f(n)。那么，只能后退一步或两步，对于第 n 阶楼梯只能回退到第 n-1 或者 n-2 阶，可以把 n-1 阶记

f(n) = f(n - 1) + f(n - 2)

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {number} n
 * @return {number}
 */
const fn = []
var climbStairs = function(n) {
  if (n === 1) {
    return 1
  }

  if (n === 2) {
    return 2
  }

  if (fn[n] === undefined) fn[n] = climbStairs(n - 1) + climbStairs(n - 2)

  return fn[n]
};
```

### 解法二：

**思路：**

>动态规划是自底向上的过程，要求我们站在已知的角度，通过定位已知和未知之间的关系，一步步向前推导，进而求解出未知的值。

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
  const f = [],
  f[1] = 1,
  f[2] = 2;

  for (let i = 3; i <= n; i++) {
    f[i] = f[i - 2] + f[i - 1]
  }

  return f[n]
};
```

## 2 找硬币

### 解法一：动态规划

**思路：**


**复杂度分析：**


**代码实现：**

```javascript
const coinChange = function(coins, amount) {
  const f = []
  f[0] = 0

  for (let i = 1; i <= amount; i++) {
    f[i] = Infinity

    for (let j = 0; j < coins.length; j++) {
      if (i - coins[j] >= 0) {
        f[i] = Math.min(f[i], f[i - coins[j]] + 1)
      }
    }
  }

  if (f[amount] === Infinity) {
    return -1
  }

  return f[amount]
}
```

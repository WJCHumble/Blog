# 栈

特点：

- 先入后出

>它的实现可以是数组或链表

## 1. 有效的括号

>https://leetcode-cn.com/problems/valid-parentheses/

解法一：栈和Map（推荐）

思路：定义一个栈用来存储未匹配的左括号，定义一个 map 来做括号的映射（key 为 右括号，value 为左括号），每次迭代（遍历字符串）如果为左括号则入栈，右括号则从 map 中匹配出左括号，并 stack 出栈，如果两个值不等则返回 false，否则继续。

>这里 map 为什么用右括号作为 key，是因为入栈的是左括号，那么取 map 的 value，就直接可以做逻辑判断。

时间复杂度：O(n)
空间复杂度：O(n)

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    // 判断字符串合法性
    if (s.length % 2 !== 0) return false;
     
    const stack = [], parenMap = new Map([[")", "("], ["}", "{"], ["]", "["]]);
    for(let i = 0; i < s.length; i++) {
        const char = s.charAt(i);
        if (!parenMap.has(char)) {
            stack.push(char);
        } else if (parenMap.get(char) !== stack.pop()) {
            return false;
        }
    }
    return !stack.length
};
```

解法二：字符串替换

思路：替换字符串中成对的括号，迭代的条件为，每次替换后的字符串长度是否等于之前字符串的长度，不等于则继续，反之结束。

时间复杂度：O(n^2/2)
空间复杂度：O(1)

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    // 判断字符串合法性
    if (s.length % 2 !== 0) return false;
    
    let length;
    while(s.length !== length) {
       length = s.length;
       s = s.replace("()", "").replace("[]", "").replace("{}", "");
    }

    return !s.length
};
```

## 2. 用栈实现队列

>https://leetcode-cn.com/problems/implement-queue-using-stacks/

解法一：

思路：在 MyQueue 上定义两个栈，一个用于存储输入的元素 inputStack，一个用于输出元素 outputStack。在 pop 和 peek 的时候需要注意，只有当 outputStack 为空的时候，才将 outputStack 中的元素加入 inputStack，然后再 pop inputStack，反之队列的顺序将会乱掉

时间复杂度：O(n)
空间复杂度：O(n)

```javascript
/**
 * Initialize your data structure here.
 */
var MyQueue = function() {
    this.inputStack = []
    this.outputStack = [];
};

/**
 * Push element x to the back of queue. 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    this.inputStack.push(x)
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    if (!this.outputStack.length) {
        while(this.inputStack.length) {
            this.outputStack.push(this.inputStack.pop())
        }
    }
    return this.outputStack.pop()
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    if (!this.outputStack.length) {
        while(this.inputStack.length) {
            this.outputStack.push(this.inputStack.pop())
        }
    }
    return this.outputStack[this.outputStack.length - 1]
};
 
/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    if (this.outputStack.length || this.inputStack.length) {
        return false
    }
    return true
};
```


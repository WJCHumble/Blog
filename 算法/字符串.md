# 字符串

## 1 反转字符串

>https://leetcode-cn.com/problems/reverse-string/submissions/

**题目描述：**

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

示例：

输入：["h","e","l","l","o"]

输出：["o","l","l","e","h"]

### 解法一：

**思路：**

定义头尾两个指针 start、end，枚举字符数组 s，每次交换两个变量，如果 start 等于数组的中间位置则退出枚举。

>这个中间位置以字符数组除于 2 向上取整来获取

**复杂度分析：**  

时间复杂度：O(n)

空间复杂度：O(1)

**代码实现：**

```javascript
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    if (!s.length) return []

    let start = 0, end = s.length - 1, center = Math.ceil(s.length / 2)
    while(start !== center) {
        let temp = s[start]
        s[start] = s[end]
        s[end] = temp
        start++
        end--
    }

    return s
};
```

## 2 反转字符串 ||

>https://leetcode-cn.com/problems/reverse-string-ii/

**题目描述：**

给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。

示例：

输入: s = "abcdefg", k = 2

输出: "bacdfeg"

### 解法一：

**思路：**



**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript

```

## 3 删除一个字符串，是否能成为回文字符串

**题目描述：**

给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

示例：

输入: "aba"

输出: True

### 解法一：双指针

**思路：**

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var validPalindrome = function(s) {
  const len = s.length

  let i = 0, j = len - 1

  const isPalindrome = (start, end) => {
    while(start < end) {
      if (s[start] !== s[end]) {
        return false
      }
      start++
      end--
    }

    return true
  }
  
  while(i < j && s[i] === s[j]) {
    i++
    j--
  }

  // 
  if (isPalindrome(i + 1, j)) {
    return true
  }

  //
  if (isPalindrome(i, j - 1)) {
    return true
  }

  return false
}
```

## 4 字符串匹配

**题目描述；**

设计一个支持以下两种操作的数据结构：

```javascript
void addWord(word)
bool search(word)
```

>search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。

示例：

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true

### 解法一：

**思路：**

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
// 构造函数
const WordDictionary = function() {
  this.words = {}
}

// 添加字符串的方法
WordDictionary.prototype.addWord = function(word) {
  // 若该字符串对应长度的数组已经存在，则只做添加
  if (this.words[word.length]) {
    this.words[word.length].push(word)
  } else {
    // 若该字符串对应长度的数组还不存在，则先创建
    this.words[word.length] = [word]
  }
}

// 搜索方法
WordDictionary.prototype.search = function(word) {
  if (!this.words[word.length]) {
    return false
  }
  // 缓存目标字符串的长度
  const len = word.length
  if (!word.includes('.')) {
    return this.words[len].includes(word)
  }

  const reg = new RegExp(word)

  return this.words[len].some((item) => {
    return reg.test(item)
  })
}
```

## 5 字符串转整数

## 6 验证回文字符串

**题目描述：**

示例：

### 解法一：正则 + 原生 API

**思路：**

正则匹配出字符串中的字母，然后组合成字符串，再通过原生 JavaScript API 来将每个单词划分为数组的每个元素，再反转数组，然后拼接成字符串

>需要注意的是，这个过程需要 toLocaleLowerCase 来转化字母为小写，避免大小写不一致造成的不相等问题

**复杂度分析：**

时间复杂度：O(nlogn)

空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    s = s.match(/[A-Za-z0-9]+/g)
    if (!s) return true

    s = s.join("")

    return s.toLocaleLowerCase() === 
            s.split("").reverse().join("").toLocaleLowerCase()
};
```

## 7 最长回文子串

>https://leetcode-cn.com/problems/longest-palindromic-substring/

参考题解：

>https://leetcode-cn.com/problems/longest-palindromic-substring/solution/hui-wen-wen-ti-dong-tai-gui-hua-jspython5-zui-chan/

**题目描述：**

示例：

### 解法一：DP 动态规划

**思路：**

**复杂度分析：**

**代码实现：**

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  if (!s || s.length === 0) return ""

  let res = s[0]
  const dp = []

  for (let i = s.length - 1; i >= 0; i--) {
    dp[i] = []
    for (let j = i; j < s.length; j++) {
      if (j - i === 0) {
        dp[i][j] = true
      }else if (j - i === 1 && s[i] === s[j]) {
        dp[i][j] = true
      }else if (s[i] === s[j] && dp[i + 1][j - 1]) {
        dp[i][j] = true
      }

      if (dp[i][j] && j - i + 1 > res.length) {
        res = s.slice(i, j + 1)
      }
    }
  }

  return res
};
```

## 8 翻转单词顺序

>https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/

### 解法一：

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    s = s.trim()
    let ans = "", sArr = s.split(" "), i = sArr.length - 1
    while(i >= 0) {
        if (!sArr[i]) {
            i--
            continue
        }
        ans += sArr[i] + " "
        i--
    }

    return ans.trim()
};
```

## 9. 左旋转字符串

> https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/

```javascript
/**
 * @param {string} s
 * @param {number} n
 * @return {string}
 */
var reverseLeftWords = function(s, n) {
    let len = s.length;
    return `${s.slice(n, len)}${s.slice(0, n)}`
};
```

## 10. 把字符串转换成整数

>https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/

```javascript
/**
 * @param {string} str
 * @return {number}
 */
var strToInt = function (str) {
    if (!str || str === '') return 0;
    let len = str.length;

    // 最大值和最小值
    const Max = Math.pow(2, 31) - 1,
      Min = Math.pow(2, 31),
      numsQueue = [];
    let pointer = 0, isNegative = false;

    // 跳过开头的指针
    while (str[pointer] === ' ') {
      pointer++;
    }

    // 开头负号的判断
    if (str[pointer] === '+' || str[pointer] === '-') {
      // 如果是负数，改变标识变量的值，正数不用变
      if (str[pointer] === '-') {
        isNegative = true;
      }
      // 指针后移
      pointer++;
    }

    // 处理后面的字符串
    for (let i = pointer; i < len; i++) {
      let char = str[pointer];
      // 如果是数字
      if (char >= '0' && char <= '9') {
        numsQueue.push(char);
      } else {
        // 其他字符直接退出循环
        break;
      }
      pointer++;
    }

    // 如果数字队列中没有数字，则为无效串，直接返回 0
    if (numsQueue.length < 1) {
      return 0
    }

    // 队列转为数字
    let res = 0;
    while (numsQueue.length) {
      res *= 10;
      // 乘一是将字符串转为数值型
      res += numsQueue.shift() * 1;
      // 溢出则推出循环
      if (res >= Max + 1) {
        break
      }
    }

    if (isNegative) {
      return res >= Max + 1 ? -Min : -res
    } else {
      return res >= Max ? Max : res
    }
  }
```
# 字符串

## 1 反转字符串

>https://leetcode-cn.com/problems/reverse-string/submissions/

**题目描述：**

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

示例：

输入：["h","e","l","l","o"]

输出：["o","l","l","e","h"]

### 解法一：

**思路：**

定义头尾两个指针 start、end，枚举字符数组 s，每次交换两个变量，如果 start 等于数组的中间位置则退出枚举。

>这个中间位置以字符数组除于 2 向上取整来获取

**复杂度分析：**  

时间复杂度：O(n)

空间复杂度：O(1)

**代码实现：**

```javascript
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    if (!s.length) return []

    let start = 0, end = s.length - 1, center = Math.ceil(s.length / 2)
    while(start !== center) {
        let temp = s[start]
        s[start] = s[end]
        s[end] = temp
        start++
        end--
    }

    return s
};
```

## 2 反转字符串 ||

>https://leetcode-cn.com/problems/reverse-string-ii/

**题目描述：**

给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。

示例：

输入: s = "abcdefg", k = 2

输出: "bacdfeg"

### 解法一：

**思路：**



**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript

```

## 3 删除一个字符串，是否能成为回文字符串

**题目描述：**

给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

示例：

输入: "aba"

输出: True

### 解法一：双指针

**思路：**

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var validPalindrome = function(s) {
  const len = s.length

  let i = 0, j = len - 1

  const isPalindrome = (start, end) => {
    while(start < end) {
      if (s[start] !== s[end]) {
        return false
      }
      start++
      end--
    }

    return true
  }
  
  while(i < j && s[i] === s[j]) {
    i++
    j--
  }

  // 
  if (isPalindrome(i + 1, j)) {
    return true
  }

  //
  if (isPalindrome(i, j - 1)) {
    return true
  }

  return false
}
```

## 3 字符串匹配

**题目描述；**

设计一个支持以下两种操作的数据结构：

```javascript
void addWord(word)
bool search(word)
```

>search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。

示例：

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true

### 解法一：

**思路：**

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
// 构造函数
const WordDictionary = function() {
  this.words = {}
}

// 添加字符串的方法
WordDictionary.prototype.addWord = function(word) {
  // 若该字符串对应长度的数组已经存在，则只做添加
  if (this.words[word.length]) {
    this.words[word.length].push(word)
  } else {
    // 若该字符串对应长度的数组还不存在，则先创建
    this.words[word.length] = [word]
  }
}

// 搜索方法
WordDictionary.prototype.search = function(word) {
  if (!this.words[word.length]) {
    return false
  }
  // 缓存目标字符串的长度
  const len = word.length
  if (!word.includes('.')) {
    return this.words[len].includes(word)
  }

  const reg = new RegExp(word)

  return this.words[len].some((item) => {
    return reg.test(item)
  })
}
```

## 4 字符串转整数

## 5 验证回文字符串

**题目描述：**

示例：

### 解法一：正则 + 原生 API

**思路：**

正则匹配出字符串中的字母，然后组合成字符串，再通过原生 JavaScript API 来将每个单词划分为数组的每个元素，再反转数组，然后拼接成字符串

>需要注意的是，这个过程需要 toLocaleLowerCase 来转化字母为小写，避免大小写不一致造成的不相等问题

**复杂度分析：**

时间复杂度：O(nlogn)

空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    s = s.match(/[A-Za-z0-9]+/g)
    if (!s) return true

    s = s.join("")

    return s.toLocaleLowerCase() === 
            s.split("").reverse().join("").toLocaleLowerCase()
};
```

## 最长回文子串

>https://leetcode-cn.com/problems/longest-palindromic-substring/

参考题解：

>https://leetcode-cn.com/problems/longest-palindromic-substring/solution/hui-wen-wen-ti-dong-tai-gui-hua-jspython5-zui-chan/

**题目描述：**

示例：

### 解法一：DP 动态规划

**思路：**

**复杂度分析：**

**代码实现：**

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  if (!s || s.length === 0) return ""

  let res = s[0]
  const dp = []

  for (let i = s.length - 1; i >= 0; i--) {
    dp[i] = []
    for (let j = i; j < s.length; j++) {
      if (j - i === 0) {
        dp[i][j] = true
      }else if (j - i === 1 && s[i] === s[j]) {
        dp[i][j] = true
      }else if (s[i] === s[j] && dp[i + 1][j - 1]) {
        dp[i][j] = true
      }

      if (dp[i][j] && j - i + 1 > res.length) {
        res = s.slice(i, j + 1)
      }
    }
  }

  return res
};
```
# 位运算

指的是对整数在内存中的二进制位进行操作

>由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快

| 符号 | 描述 | 运算规则 |
|  ----  | ----  | --- |
| & | 与 | 两个位都为 1 时，结果才为 1 |
| | | 或 | 两个位都为 0 时，结果才为 0 |
| ^ | 或 | 两个位都为 0 时，结果才为 0 |
| ~ | 或 | 两个位都为 0 时，结果才为 0 |
| << | 左移 | 两个位都为 0 时，结果才为 0 |
| >> | 右移 | 两个位都为 0 时，结果才为 0 |

> 待完善

## 位运算常用操作

1. x & 1 === 1 OR === 0 判断奇偶（x % 2 === 1）

2. x = x & (x - 1) => 清零最低位的 1

假设此时 x 为 10100000，那么 x - 1 就会是 10011111，那么 x & (x - 1 则会是 10000000

3. x & -x => 得到最低位的 1

## 位运算的应用


## 1. 位1的个数

>https://leetcode-cn.com/problems/number-of-1-bits/

**题目描述：**

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

示例：

输入：00000000000000000000000000001011
输出：3


### 解法一：循环和位移动

**思路：**

直接遍历数字的 32 位，如果该位置是 1，则将计数器加一。用位掩码来检查数字的第 i 位，初始为 1，因为 1 的二进制为：

0000 0000 0000 0000 0000 0000 0001

每次迭代将该数字与掩码进行与操作，如果结果为 1 则代表该位置的数字为 1，否则为 0 则代表该位置的数字为 0。

**复杂度分析：**

时间复杂度：O(1)

空间复杂度：O(1)

**代码实现：**

```javascript
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
    let count = 0, mask = 1;
    
    for (let i = 0; i < 32; i++) {
      if ((n & mask) !== 0) {
        count++;
      }
      mask <<= 1
    }

    return count
};
```

## 解法二：位运算小技巧

**思路：**

当 n 不为 0 的时候，迭代时，将 n & (n - 1) 且赋值给 n，如果 n 不为 0 则 1 的次数加一。

**复杂度分析：**

时间复杂度：O(1)

空间复杂度：O(1)

**代码实现：**

```javascript
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function(n) {
  let count = 0;

  for (; n; n &= n - 1) {
    ++count
  }

  return count
}
```

## 2. 2 的幂

>https://leetcode-cn.com/problems/power-of-two/

**题目描述：**

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

示例：

输入: 16

输出: true

### 解法一：

**思路：**

由于 2 的幂的二进制表示有且仅有一个 1，那么将 n & (n - 1) 则会等于 0。

**复杂度分析：**

时间复杂度：O(1)

空间复杂度：O(1)

**代码实现：**

```javascript
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    if (n > 0 && (n & (n - 1)) === 0) {
        return true
    }
    
    return false
};
```

## 3. 比特位计数

>https://leetcode-cn.com/problems/counting-bits/

**题目描述：**

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例：

输入: 2

输出: [0,1,1]

### 解法一：分别计算每个数字的二进制位 1 的个数

**思路：**

**复杂度分析：**

时间复杂度：O(n)

空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
    const res = []

    const hammingWeight = (n) => {
        let bites = 0
        for (; n; n &= n - 1) {
            ++bites
        }

        return bites
    }

    for (let i = 0; i <= num; i++) {
        let counts = hammingWeight(i)
        res.push(counts)
    }

    return res
};
```

### 解法二：使用位运算的结果作为索引

**思路：**

用去除最后一位 1 的二进制数来作为

**复杂度分析：**

时间复杂度：O(n)

空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
    const count = [0]

    for (let i = 1; i <= num; i++) {
        count[i] = count[i & (i - 1)] + 1
    }

    return count
};
```

## 4. N 皇后

>https://leetcode-cn.com/problems/n-queens-ii/

**题目描述：**

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。

示例：

### 解法一：位运算

**思路：**


**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var totalNQueens = function(n) {
  if (n < 1) return []

  let count = 0
  const dfs = (n, row, cols, pie, na) => {
    if (row >= n) {
      count += 1
      return
    }

    // 对可以放置的位（0），取反，即将 0 转为 1,并且
    bits = (~(cols | pie | na) & (1 << n) - 1)

    while (bits) {
      // 找到最低位的 1
      p = bits & -bits
      // 
      dfs(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1)
      // 去掉最低位的 1
      bits = bits & (bits - 1)
    }
  }

  dfs(n, 0, 0, 0, 0)
  return count
};
```
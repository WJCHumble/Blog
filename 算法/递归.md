# 递归和分治

## 递归

递归就是一种循环，是指通过函数体来进行循环

故事：
1.从前有个山
2.山里有个庙
3.庙里有个和尚讲故事

>这里例子的递归是没有退出条件的，所以会发生栈溢出的情况

例如：

1.计算 n!
```javascript
function factorial(n) {
  if (n <= 1)
    return 1;
  return n * factorial(n - 1);
}
```

2.斐波那契数列
```javascript
function fib(n) {
  if (n === 0 || n === 1) return n;

  return fib(n-1) + fib(n-2);
}
```

## 分治 Divde & Conquer

分治，其实就是将大问题转为小问题，然后解决小问题


## 1.Pow(x, n)

>https://leetcode-cn.com/problems/powx-n/

**题目描述：**

### 解法一：分治 + 递归（快速幂）

**思路：**

将 x 的 n 次方问题转为 x 的 n/2 次方的平方问题，对于 n 为奇数的情况需要再乘上一个 x。

递归的边界值处理：

- 递归到 n 为 0 时，此时返回 1，因为 x 的 0 次方为 1
- 递归到 n 为 负数，返回 1 / x^-n
- n 为奇数的时候，需要返回 x * x^n-1/2

**复杂度分析：**

时间复杂度：O(logn)

空间复杂度：O(logn)

**代码实现：**
```javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  if (!n) return 1;
  if (n < 0) return 1 / myPow(x, -n);
  if (n % 2) return x * myPow(x, n-1);

  return myPow(x * x, n/2)
};
```

### 解法二：迭代

**思路：**

**复杂度分析：**

**代码实现：**
```javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  if (n < 0) {
    x = 1 / x;
    n = -n;
  }

  pow = 1;
  while(n) {
    if (n && 1) {
      pow *= x;
    }
    x *= x
    n >>= 1
  }
  return pow
};
```

## 2 多数元素

>https://leetcode-cn.com/problems/majority-element/

**题目描述：**

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

>你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例：

输入: [3,2,3]
输出: 3

### 解法一：暴力迭代数组 + Map 计数

**思路：**

直接迭代次数组，找出其中出现次数最多的元素。

>其实还有种方法迭代两次数组，来计数，但是显然用 Map 空间换时间会比较 Geek。

**复杂度分析：**

时间复杂度：O(n^2)

空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    const countMap = new Map();
    for(let i = 0; i < nums.length; i++) {
        if (countMap.has(nums[i])) {
            const times = countMap.get(nums[i]) + 1;
            countMap.set(nums[i], times)
        } else {
            countMap.set(nums[i], 1)
        }
    }
    let maxTimes = 0, num;
    // 遍历 map 找出出现次数最多的元素
    for(let [key, value] of countMap) {
        if (value > maxTimes) {
            maxTimes = value;
            num = key 
        }
    }
    return num
};
```

### 解法二：排序

**思路：**

对数组进行排序，相同的元素会连续排在一起，这样我们可以迭代排序后的数组来计算元素出现的次数。

**复杂度分析：**

时间复杂度：O(nlogn)

空间复杂度：O(nlogn)

**代码实现：**

```javascript

```

### 解放三：分治

**思路：**

**复杂度分析：**

时间复杂度：O(nlogn)

空间复杂度：O(1)

**代码实现：**

```javascript

```

## 3. 全排列

>https://leetcode-cn.com/problems/permutations/

**题目描述：**

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例：

输入: [1,2,3]

输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

### 解法一：DFS

**抽象模型：**

- 返回值：每次排列好的元素
- 调用单元：如果 `nums[i]` 没有被放入 currentRet 中，则 `nums[i]` 加入 currentRet
- 终止条件：访问了 3 次后，将 currentRet 加入 finalRet 中

**复杂度分析：**

时间复杂度：O(n)

空间复杂度：O(n^2)

**代码实现：**

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const len = nums.length, currentRet = [], finalRet = [], set = new Set();

    var dfs = function(times) {
        if (times === len) {
            finalRet.push(currentRet.slice())
            return
        }

        for (let i = 0; i < len; i++) {
            if (set.has(nums[i])) continue

            set.add(nums[i])
            currentRet.push(nums[i])
            dfs(times+1)
            currentRet.pop()
            set.delete(nums[i])
        }
    }
    
    dfs(0)
    return finalRet
};
```

## 4. 子集

>https://leetcode-cn.com/problems/subsets/

**题目描述：**

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

>解集不能包含重复的子集。

示例：

输入: nums = [1,2,3]

输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

### 解法一：DFS

**思路：**

- 返回值：
- 调用单元：
- 终止条件：

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
const subsets = function(nums) {
  const res = [], len = nums.length, subset = [];

  dfs(0)

  var dfs = function(index) {
    res.push(subset.slice())
    for (let i = index; i < len; i++) {
      subset.push(nums[i])
      dfs(i+1)
      subset.pop()
    }
  }

  return res
}
```



# 递归和分治

## 递归

递归就是一种循环，是指通过函数体来进行循环

故事：
1.从前有个山
2.山里有个庙
3.庙里有个和尚讲故事

>这里例子的递归是没有退出条件的，所以会发生栈溢出的情况

例如：

1.计算 n!
```javascript
function factorial(n) {
  if (n <= 1)
    return 1;
  return n * factorial(n - 1);
}
```

2.斐波那契数列
```javascript
function fib(n) {
  if (n === 0 || n === 1) return n;

  return fib(n-1) + fib(n-2);
}
```

## 分治 Divde & Conquer

分治，其实就是将大问题转为小问题，然后解决小问题


## 1.Pow(x, n)

>https://leetcode-cn.com/problems/powx-n/

**题目描述：**

### 解法一：分治 + 递归（快速幂）

**思路：**

将 x 的 n 次方问题转为 x 的 n/2 次方的平方问题，对于 n 为奇数的情况需要再乘上一个 x。

递归的边界值处理：

- 递归到 n 为 0 时，此时返回 1，因为 x 的 0 次方为 1
- 递归到 n 为 负数，返回 1 / x^-n
- n 为奇数的时候，需要返回 x * x^n-1/2

**复杂度分析：**

时间复杂度：O(logn)

空间复杂度：O(logn)

**代码实现：**
```javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  if (!n) return 1;
  if (n < 0) return 1 / myPow(x, -n);
  if (n % 2) return x * myPow(x, n-1);

  return myPow(x * x, n/2)
};
```

### 解法二：迭代

**思路：**

**复杂度分析：**

**代码实现：**
```javascript
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
var myPow = function(x, n) {
  if (n < 0) {
    x = 1 / x;
    n = -n;
  }

  pow = 1;
  while(n) {
    if (n && 1) {
      pow *= x;
    }
    x *= x
    n >>= 1
  }
  return pow
};
```

## 2 多数元素

>https://leetcode-cn.com/problems/majority-element/

**题目描述：**

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

>你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例：

输入: [3,2,3]
输出: 3

### 解法一：暴力迭代数组 + Map 计数

**思路：**

直接迭代次数组，找出其中出现次数最多的元素。

>其实还有种方法迭代两次数组，来计数，但是显然用 Map 空间换时间会比较 Geek。

**复杂度分析：**

时间复杂度：O(n^2)

空间复杂度：O(n)

**代码实现：**

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    const countMap = new Map();
    for(let i = 0; i < nums.length; i++) {
        if (countMap.has(nums[i])) {
            const times = countMap.get(nums[i]) + 1;
            countMap.set(nums[i], times)
        } else {
            countMap.set(nums[i], 1)
        }
    }
    let maxTimes = 0, num;
    // 遍历 map 找出出现次数最多的元素
    for(let [key, value] of countMap) {
        if (value > maxTimes) {
            maxTimes = value;
            num = key 
        }
    }
    return num
};
```

### 解法二：排序

**思路：**

对数组进行排序，相同的元素会连续排在一起，这样我们可以迭代排序后的数组来计算元素出现的次数。

**复杂度分析：**

时间复杂度：O(nlogn)

空间复杂度：O(nlogn)

**代码实现：**

```javascript

```

### 解法三：分治

**思路：**

**复杂度分析：**

时间复杂度：O(nlogn)

空间复杂度：O(1)

**代码实现：**

```javascript

```

## 3. 全排列

>https://leetcode-cn.com/problems/permutations/

**题目描述：**

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例：

输入: [1,2,3]

输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

### 解法一：DFS

**抽象模型：**

- 返回值：每次排列好的元素
- 调用单元：如果 `nums[i]` 没有被放入 currentRet 中，则 `nums[i]` 加入 currentRet
- 终止条件：访问了 3 次后，将 currentRet 加入 finalRet 中

**复杂度分析：**

时间复杂度：O(n)

空间复杂度：O(n^2)

**代码实现：**

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const len = nums.length, currentRet = [], finalRet = [], set = new Set();

    var dfs = function(times) {
        if (times === len) {
            finalRet.push(currentRet.slice())
            return
        }

        for (let i = 0; i < len; i++) {
            if (set.has(nums[i])) continue

            set.add(nums[i])
            currentRet.push(nums[i])
            dfs(times+1)
            currentRet.pop()
            set.delete(nums[i])
        }
    }
    
    dfs(0)
    return finalRet
};
```

## 4. 子集

>https://leetcode-cn.com/problems/subsets/

**题目描述：**

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

>解集不能包含重复的子集。

示例：

输入: nums = [1,2,3]

输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

### 解法一：DFS

**思路：**

- 返回值：
- 调用单元：
- 终止条件：

**复杂度分析：**

时间复杂度：O(n * 2^n)

>每个位置可能有两种状态，有或者没有，每种状态需要 O(n) 的时间构造子集

空间复杂度：O(n)

>需要额外临时数组来存储子集

**代码实现：**

```javascript
const subsets = function(nums) {
  const res = [], len = nums.length, subset = [];

  dfs(0)

  var dfs = function(index) {
    res.push(subset.slice())
    for (let i = index; i < len; i++) {
      subset.push(nums[i])
      dfs(i+1)
      subset.pop()
    }
  }

  return res
}
```

## 6. N 皇后

>https://leetcode-cn.com/problems/n-queens/

**题目描述：**

n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

示例：

输入：4

输出：[
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]

### 解法一：DFS

**思路：**



**时间复杂度：**

空间复杂度：

时间复杂度：

**代码实现：**

```javascript
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
  if (!n) return []

  const result = [],
        cols = new Set(),
        pie = new Set(),
        na = new Set();

  const DFS = (n, row, currentState) => {
    if (row >= n ) {
      result.push(currentState)
      return
    }

    for (let col = 0; col < n; col++) {
      if (cols.has(col) || pie.has(row + col) || na.has(row - col)) {
        continue
      }

      cols.add(col)
      pie.add(row + col)
      na.add(row - col)

      DFS(n, row + 1, [...currentState, col])

      cols.delete(col)
      pie.delete(row + col)
      na.delete(row - col)
    }
  }

  DFS(n, 0, [])
  const generateResult = n => {
    const board = []

    for (let sub of result) {
      let res = []
      for (let i of sub) {
        borad.push(`${'.'.repeat(i)}Q${'.'.repeat(n - i - 1)}`)
      }
      board.push(res)
    }
    
    return board
  }

  return generateResult(n)
};
```

### 解法二：极简版 DFS

**思路：**



**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
  if (!n) return []

  const result = [],
    cols = new Set(),
    pie = new Set(),
    na = new Set()

  const DFS = (n, row, curState) => {{
    // 递归边界，最后一行
    if (row >= n) return result.push(curState)
    
    // 迭代列
    for (let col = 0; col < n; col++) {
      // 如果列在皇后不允许的范围，则继续
      if (cols.has(col) || pie.has(row + col) || na.has(row - col)) continue

      // 放入改皇后，设置攻击的位置
      cols.add(col)
      pie.add(row + col)
      na.add(row - col)
      
      // 递归下一列，将当前位置放入皇后中
      DFS(n, row + 1, [...curState, col])

      // 下个放置方法，删除攻击位置
      cols.delete(col)
      pie.delete(row + col)
      na.delete(row - col)
    }
  }}

  DFS(n, 0, [])

  // 生成结果
  const generateResult = n => {
    const board = []
    // result 是什么数据结构
    for (const sub of result) {
      let res = []
      for (const i of sub) {
        // 点的数量需要注意一下
        res.push('.'.repeat(i) + 'Q' + '.'.repeat(n - i - 1))
      }
      board.push(res)
    }

    return board
  }

  return generateResult(n)
}
```

## 7. 组合

>https://leetcode-cn.com/problems/combinations/

**问题描述：**

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例：

输入: n = 4, k = 2

输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

**抽象模型：**


**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
  const result = [], currentState = []

  const dfs = (index) => {
    if (currentState.length === k) {
      result.push(currentState.slice())
    }

    for (let i = index; i <= n; i++) {
      currentState.push(i)
      dfs(i + 1)
      currentState.pop()
    }
  }

  dfs(1)

  return res
};
```

## 8. 数独

>https://leetcode-cn.com/problems/valid-sudoku/

**题目描述：**

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

示例：

输入:

[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]

输出: true

### 解法一：

**思路：**

**复杂度分析：**

时间复杂度：

空间复杂度：

**代码实现：**

```javascript
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board, n = {}) {
  const valid = (k, n) => h[k] ? (h[k][n] ? false : h[k][n] = 1) : (h[k] = [], h[k][n] = 1) 

  for (let i = 0; i < 9; i++) {
    for (let j = 0, m = i / 3 | 0; n = j / 3 | 0, j < 9; j++) {
      if (board[i][j] !== '.' && (!v(18 + m * 3 + n, board[i][j]) ||
          !v(18 + m * 3 + n, board[i][j])  ||
          !v(i, board[i][j]) ||
          !v(j + 9, board[i][j])
      )) return false
    }
  }

  return true
}
```



